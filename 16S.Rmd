#load phyloseq object
```{r}
library(phyloseq)
ps <- readr::read_rds('./DATA/ps_phenotype.rds')

#rank_names(ps)
meta <- as(ps@sam_data,'data.frame')
unique_ids <- meta %>%
  distinct(ID_KYH, .keep_all = TRUE) 

otu <- ps@otu_table
tax <- ps@tax_table
ps <- phyloseq(otu,tax, sample_data(unique_ids))
ps
tax_tab <- as(tax_table(ps),'data.frame')
tax_tab$ASV <- rownames(tax_tab)
tax_tab$taxa_names <- gsub(" ", "_", paste0(tax_tab$ASV, '|', tax_tab$Genus, '|', tax_tab$Species))
tax_tab <- as.matrix(tax_tab)
tax_table(ps) <- phyloseq::tax_table(tax_tab)

#duplicate(ps@sam_data$ID_KYH)
#ps <- readRDS('~/ps_17_22.rds')
write.csv(as(ps@sam_data,'data.frame'),'./DATA/meta.csv') 
saveRDS(ps,'16s_without_duplicates.rds')
```
#duplicate
```{r,fig.height=8,fig.width=10}
library(phyloseq)
library(dplyr)

ps <- readr::read_rds('./DATA/ps_phenotype.rds')

meta <- as(ps@sam_data,'data.frame')
meta$ID_KYH <- as.character(meta$ID_KYH)
meta$ID_KYH

duplicated_ids <- meta %>%
  group_by(ID_KYH) %>%
  summarise(count = n()) %>%
  filter(count > 1) %>%
  pull(ID_KYH)

# Фильтруем только те образцы, которые имеют дубликаты
duplicated_samples <- meta %>%
  filter(ID_KYH %in% duplicated_ids)

# Создаем phyloseq объект только с дублированными образцами
ps_duplicated <- subset_samples(ps, ID_KYH %in% duplicated_ids)

ps_obj <- octobiom::prepare_phyloseq(ps_duplicated,transformation = 'compositional',detection = 10,prev = 0.05,taxonomic_level = 'Genus',
                                     first = 'filter')
?octobiom::barplot_hierarchical
#Creates a stacked barplot of taxonomic compositions with hierarchical clustering dendrogram and sample metadata annotations for top taxa.
features <- c('batch' )
color_palette <- octobiom::get_palette("set_20_2")
color_palette <- c('white',color_palette)
colors_annotation <- list('batch' = octobiom::get_palette("set_10_2"))
octobiom::barplot_hierarchical(ps_obj,taxrank="Genus", top = 20, feature = features,
                                      dist = 'bray',colors_barplot = color_palette,
                                   colors_annotation = colors_annotation,decreasing = T,
                                   size = c(0.5,0.5,5),colnames = T)


```
#load library
```{r}
library(phyloseq)
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(lemon)
library(phyloseq)
library(PNWColors)
library(microbiome)
library(patchwork)
library(pheatmap)
library(RColorBrewer)
library(grid)
library(NetCoMi)
library(DirichletMultinomial)
library(parallel)
library(purrr)
library(vegan)
library(tibble)
library(tidyverse)
library(dplyr)
library(reshape2)

source("./code/permanova.R")
source("./code/beta_alpha.R")
source("./code/DMM.R")


```
#colors
```{r}
c25 <- c("gray70",
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
   "gold1",
  "skyblue2", "#FB9A99", # lt pink
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
   "khaki2",
  "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4", "brown","magenta"  ,      'orange',                     
 'skyBlue',
 'Green',                   
 'yellow',                      
  'blue',                      
  'aquamarine',
 '#DC3220',
  '#4B0092',
  '#E1BE6A',
  'black',
 '#40B0A6',
  '#994F00',
  "pink3","black"
)
c10 <- c('#9e0142','#d53e4f','#f46d43','#fdae61','#fee08b',
         '#e6f598','#abdda4','#66c2a5','#3288bd','#5e4fa2')
colors <- c('#34b9ed','#a100bf',
'#f7b126','#bf4380','#1d8dcf',
'#024cc1',
'#f0e74c','#b2d1e3',
'#cc7daa',

'#ff594c'
)
  
size=20
theme1 = theme(
    plot.title = element_text(color = "black", size=size),
    axis.text.y = element_text(color = "black", size = size),
    axis.text.x = element_text(angle=90, hjust=1,size=size,color = 'black'),
    legend.position = "none",
    axis.title.y  = element_text(color = "black", size = size,angle=90),
    axis.title.x  = element_text(color = "black", size = size),
    #legend.key.size = unit(0.5, 'cm'),
    text = element_text(size = size,colour ='black' ))

prepare_count_table <- function (ps_obj, taxa_name_func) {
  otu_matrix <- as(otu_table(ps_obj), 'matrix')
  taxa_matrix <- as(tax_table(ps_obj), 'matrix')
  taxa_matrix <- cbind(ASV=rownames(taxa_matrix), taxa_matrix)  
  taxa_matrix_good_names <- apply(taxa_matrix, MARGIN=1, taxa_name_func)
  # ps_meta <- as(sample_data(ps_obj), 'matrix')
  colnames(otu_matrix) <- taxa_matrix_good_names
  return(otu_matrix)
}

# Assuming `ps_obj` is your phyloseq object and `taxa_name_func` is defined
taxa_name_func <- function(x) {paste0(x['Genus'])}#,  '_', gsub('/', '', gsub("-", "", x['Genus'])))}#, gsub('/', '', gsub("-", "", x['Species'])))}

save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   pdf(filename, width=width, height=height)
   grid::grid.newpage()
   grid::grid.draw(x$gtable)
   dev.off()
}
min_reads <- 1000
```
#rarecurve
```{r}
otu_long <- as.data.frame(t(ps@otu_table)) %>%
  rownames_to_column(var = "Taxon") %>%
  pivot_longer(-Taxon, names_to = "Sample", values_to = "Count")

df_plot <- otu_long %>%
  group_by(Sample) %>%
  summarise(TotalReads = sum(Count), .groups = "drop")

df_plot$TotalReads <- as.numeric(df_plot$TotalReads)

library(ggplot2)
library(patchwork) # Для компоновки графиков
library(vegan) # Для rarefaction curve

# Основной Violin plot с улучшениями
violin_plot <- ggplot(df_plot, aes(x = "", y = TotalReads)) +
  geom_violin(trim = FALSE, fill = "#FFEBAF", color = "black", alpha = 0.7) +
  geom_boxplot(width = 0.1, fill = "white", color = "black", outlier.shape = NA) +
  geom_point(aes(y = mean(TotalReads)), 
             shape = 18, size = 3, color = "black") +
  geom_label(aes(x = "", y = mean(TotalReads), 
                label = paste0("Mean = ", round(mean(TotalReads)))),
            vjust = -1, color = "#4C9DB0", size = 3.5) +
  labs(x = "", y = "Total Reads") +
  scale_y_continuous(labels = scales::comma) +
  theme_minimal(base_size = 12) +
  theme(
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    axis.text = element_text(color = "black"),
    axis.title = element_text(face = "bold")
  )
violin_plot
# Rarefaction curve (пример)
# Вам нужно заменить "otu_table" на вашу реальную таблицу OTU
tab <- as.matrix(otu_table(ps))
class(tab) <- "matrix"

rare_curves <- rarecurve(tab, step=1000, cex=0.5, label=FALSE)
rare_curves

sample_names <- rownames(tab)

# Вычисляем максимальную длину
x_vals <- seq(0, max(sapply(rare_curves, function(x) max(attr(x, "Subsample")))), by=1000)

# Создаём датафрейм для ggplot2
df <- data.frame(Sample = factor(rep(sample_names, each=length(x_vals))),
                 Reads = rep(x_vals, times=length(sample_names)),
                 Richness = NA)

# Заполняем значения Richness для каждого образца
for(i in 1:length(sample_names)) {
    subs <- attr(rare_curves[[i]], "Subsample")
    rich <- rare_curves[[i]]
    df[df$Sample == sample_names[i], "Richness"] <- approx(subs, rich, x_vals, rule = 2)$y
}  

rare_data <- do.call(rbind, lapply(1:length(rare_curve), function(i) {
  data.frame(
    Reads = attr(rare_curve[[i]], "Subsample"),
    OTUs = rare_curve[[i]],
    Sample = i
  )
}))

rare_curve_plot <- ggplot(rare_data, aes(x = Reads, y = OTUs,group =Sample)) +
  geom_line(color = "#ff7029", alpha = 0.5) +
  labs(x = "Sequencing Depth", y = "Observed OTUs") +
  theme_minimal(base_size = 12) +
  theme(
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank(),
    axis.text = element_text(color = "black"),
    axis.title = element_text(face = "bold")
  )

combined_plot <- violin_plot + rare_curve_plot + 
  plot_layout(widths = c(1, 1.5)) +
  plot_annotation(tag_levels = 'A') &
  theme(plot.tag = element_text(face = "bold"))

# Вывод
print(combined_plot)

# Сохранение
ggsave("./figures/reads_distribution_with_rarefaction.png", 
       combined_plot, width = 10, height = 5, dpi = 300)
  
```
#Heatmap
``` {r, fig.height=90, fig.width=70}
ps_obj <- ps
year <- '2017 16S'
det <- 1
prev<- 10/100

# ==============================================================================
# Filter taxa

taxas <- core_members(ps_obj, detection = det, prevalence = prev)
ps_obj <- prune_taxa(taxas, ps_obj)

print('After taxa filtering:')
ps_obj


# ==============================================================================
# Agglomeration
tax_glom_level <- 'Genus'

#This method merges species that have the same taxonomy at a certain taxonomic rank.
if (tax_glom_level != 'ASV'){
  ps_obj <- speedyseq::tax_glom(ps_obj, tax_glom_level, NArm = F)
}

print('After agglomeration:')
ps_obj


# ==============================================================================
# Transform counts
###Transformation to apply. The options include: 'compositional' (ie relative abundance), 'Z', 'log10', 'log10p', 'hellinger', 'identity', 'clr', 'alr', or any method from the vegan::decostand function \\centered log-ratio transformation (clr)
transformation <- 'clr'
ps_obj <- microbiome::transform(ps_obj, transformation)


# ==============================================================================
# Prepare metadata table
ps_meta <- as(sample_data(ps_obj), 'data.frame')
meta_for_heat <- ps_meta[, (names(ps_meta) %in% c('phenotype','batch'))]
meta_for_heat <- ps_meta[, (names(ps_meta) %in% c('phenotype','YEAR'))]

#rownames(meta_for_heat) <- rownames(ps_meta)

count_mtrx <- prepare_count_table(ps_obj, taxa_name_func)

cc <- as.data.frame(count_mtrx)
rownames(meta_for_heat) <- rownames(cc)


# ==============================================================================
# Plot Heat
clustering_distance_rows <- 'euclidean'
# clustering_distance_rows <- 'binary'
# clustering_distance_rows <- 'correlation'

clustering_distance_cols <- 'euclidean'
#clustering_distance_cols <- 'binary'
# clustering_distance_cols <- 'correlation'

filenames <- paste( './figures/','tax_glom_level_', tax_glom_level, '_transform_', transformation, '_det', det, '_prev',prev, '_minreads', min_reads, '_clust_dist_cols_', clustering_distance_cols,  '_clust_dist_rows_', clustering_distance_rows,' year:',year, '.pdf')

filenames <- paste( '~/DAVID_WGS/taxa/inStrain/','tax_glom_level_', tax_glom_level, '_transform_', transformation, '_det', det, '_prev',prev, '_minreads', min_reads, '_clust_dist_cols_', clustering_distance_cols,  '_clust_dist_rows_', clustering_distance_rows,' year:',year, '.pdf')

ann_colors <- list(
   batch = c("B1"='#9e0142',
             "B3"='#e6f598',
             "B4"='#abdda4',
             "B6"='#fdae61',
             "B7"='#3288bd'),
   phenotype = c(`1st`= "#5e4fa2",
              `2nd` = "#26FF2E",
              `3rd` = "#1600FC",
              `4th`= "#FFD2D7"))

p1 <- pheatmap( t(cc), cluster_rows = T, treeheight_row  = 600, treeheight_col = 700,
          cluster_cols = T, 
          annotation_col = meta_for_heat,
          annotation_colors = ann_colors,
          # annotation_row = meta_for_taxa,
          # col= hmcols, 
          # breaks = bk,
          # main=paste0('Features: ', dim(t(ordered_counts)), '; Samples: ', length(rownames(ordered_counts)), '; Prevalence: ', prevalence, '; Detection: ', detection, '; Min reads: ', min_reads ),
          silent=F,
          clustering_distance_rows=clustering_distance_rows,
          #clustering_distance_cols=clustering_distance_cols,
          clustering_method='ward.D2',
          #gaps_col = breaks,
          cutree_rows = 30,
          # cutree_cols = 50,
          show_rownames = T,
          show_colnames = T,
          #filename= paste('tax_glom_level_', tax_glom_level, '_transform_', transformation, '_det', det, '_prev',prev, '_minreads', min_reads, '_clust_dist_cols_', clustering_distance_cols,  '_clust_dist_rows_', clustering_distance_rows,' year:',year, '.pdf'), 
          width=30, height = 80, border_color=NA
          )

save_pheatmap_pdf(p1, filenames,width=70, height = 160)

p1


heatmap_object <- Heatmap(t(otu_table),
                          width=100, height = 200,
                          row_names_gp    = gpar(fontsize = 5),
                          column_names_gp = gpar(fontsize = 0),
                          column_names_rot = 45,
                          name = 'MAG abundance(compositional)',
                          heatmap_legend_param = list(direction = "horizontal"))
draw(heatmap_object,heatmap_legend_side = "top", annotation_legend_side = "top",merge_legend = T)
```
#permanova
```{r,fig.width=14}
source("./code/permanova.R")
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'NONE',detection = 10, prevalence = 0.05,taxonomic_level = 'taxa_names',first = 'filter')
ps_obj@sam_data$bmi_group
ps_obj <- subset_samples(ps_obj, 
                               !is.na(sample_data(ps_obj)$cancer) &
                               !is.na(sample_data(ps_obj)$liver_diseases) &
                               !is.na(sample_data(ps_obj)$dietary_quality_score_cat) &
                                 !is.na(sample_data(ps_obj)$total_phys_act_index)                         )

ps_obj@sam_data$age <- ps_obj@sam_data$age_at_heath_check_10yr
factor(ps_obj@sam_data$age_at_heath_check_10yr)
ps_obj@sam_data$ISCO <- ps_obj@sam_data$ISCO_group
ps_obj@sam_data$diet_quality <- ps_obj@sam_data$dietary_quality_score_cat
ps_obj@sam_data$physical_activity <- ps_obj@sam_data$total_phys_act_index
#df <- as(ps_obj@sam_data,'data.frame')
#colnames(df) <- recode(colnames(df),
#                      `kidney_disease` = "kidney disease",
#                      `drinking_level` = "drinking level",
#                      `diet_quality` = "diet quality",
#                      `physical_activity` = "physical activity",
#                      `smoking_status` = "smoking status")
#ps_obj@sam_data <- sample_data(df)
formula <- ' age + education + cancer + kidney_disease + ISCO  + diet_quality  +  physical_activity + smoking_status + phenotype + batch + sex + drinking_level'
#+ lipid_mod_agents_med + antidiab_med


#formula <- 'phenotype +  sex + age_at_heath_check_10yr + education + cancer+ kidney_disease + drinking_level  + antidiab_med + dietary_quality_score_cat + liver_diseases + current_smoker + bmi_group'

#cols_meta <- data.frame(
#  category = c('comorbidities','general','general','lifestyle','comorbidities'
#            ,'comorbidities','lifestyle','drugs','lifestyle',
#            'comorbidities','lifestyle','comorbidities'), 
#  row.names = c("phenotype", #"sex",'age_at_heath_check_10yr','education','cancer','kidney_disease','drinking_l#evel',
#                 'antidiab_med','dietary_quality_score_cat' , 
#                  'liver_diseases','current_smoker','bmi_group'))

cols_meta <- data.frame(
  category = c('comorbidities','technical','sociodemographic','sociodemographic','sociodemographic','self-reported\n chronic diseases','self-reported\n chronic diseases','behavioral\n factors','behavioral\n factors',
            'sociodemographic','sociodemographic','behavioral\n factors'), 
  row.names = c("phenotype", "batch", "sex",'age','education','cancer','kidney_disease','drinking_level',
                  'diet_quality' , 
                  'physical_activity','ISCO','smoking_status'))
cols_meta$new_name <- rownames(cols_meta)
category_order <- c('comorbidities','sociodemographic','behavioral\n factors', 'self-reported\n chronic diseases','technical')

# Reorder the factor levels in cols_meta
cols_meta$category <- factor(cols_meta$category, levels = category_order)

methods <- c('euclidean')
method <- 'bray'
# Run the plot_permanova function for both methods

palette <- pnw_palette("Spring", n=length(unique(cols_meta$category)))
threshold <- 0.0055
list_order <- c('phenotype','age','sex', 'education', 'ISCO', 'physical_activity', 'diet_quality', 'smoking_status', 'drinking_level','cancer','kidney_disease','batch')
ps_obj <- ps
threshold <- 0
det <- 0
prev <- 0
color_palette <- octobiom::get_palette("set_10_3")
plot_list <- purrr::map(methods, ~ {
  tryCatch({
    plot_permanova(ps_obj, formula, method = .x, 
                   show_plot = TRUE, level = level, 
                   det = det, prev = prev, 
                   year = year, lab.size = lab.size, 
                   size = 10, cols_meta= cols_meta,palette=color_palette,threshold =threshold ,threshold_loc_y = 16)
  }, error = function(e) {
    message(paste("Error in method:", .x))
    message(e$message)  # Print the error message
    return(NULL)  # Return NULL for this iteration
  })
})

# Check results
print(plot_list)

figure <- ggarrange(plotlist = list(plot_list[[1]][[2]],plot_list[[2]][[2]]),nrow =2,ncol = ceiling(length(plot_list)/2),labels = c('A', 'B'))
figure

#png("~/final_16s_arhangelsk/permanova.pdf", units = "cm",res = 300)
#figure
#dev.off()
plot_list[[1]][[2]]
ggsave("./figures/permanova_asv.png",figure,dpi=300,height = 10,width=12)
ggsave("~/virus/figures/permanova.png",plot_list[[1]][[2]],dpi=300,height = 6,width=20)
```
#beta and alpha 
```{r,fig.height=10}
source("./code/beta_alpha.R")
ps_obj <- ps
ps_obj <- subset_samples(ps_obj, 
                               !is.na(sample_data(ps_obj)$cancer) &
                               !is.na(sample_data(ps_obj)$liver_diseases) &
                               !is.na(sample_data(ps_obj)$dietary_quality_score_cat) &
                                 !is.na(sample_data(ps_obj)$total_phys_act_index)
                         )
level <- 'Genus'
year <- '2017 16S'
det <- 1
prev<-10/100
meta <- as(ps_obj@sam_data,'data.frame')
meta <- meta %>%
  dplyr::mutate(phenotype = recode(phenotype,
                             `1st` = "MHN",
                             `2nd` = "MUN",
                             `3rd` = "MHO",
                             `4th` = "MUO"))
ps_obj@sam_data <- sample_data(meta)

trans <- 'compositional'
distance_method <- 'bray' #euclidean

ps_obj <- speedyseq::tax_glom(ps_obj,taxrank = level, NArm=T )
taxas <- core_members(ps_obj, detection = det, prevalence = prev)
ps_obj <- prune_taxa(taxas, ps_obj)

ps_obj <- microbiome::transform(ps_obj, trans)
palette <- pnw_palette("Bay",4)
# Example usage
beta <- create_ordination_plots(ps_obj, method = "PCoA", distance_method = distance_method , group = "phenotype", size = 15,palette = colors,level_factors= c("MHN","MUN","MHO","MUO"))

measure <- 'Shannon'
method <- 'wilcox.test'

my_comparisons <- list( c("MHN", "MUN"), c("MHN", "MHO"), c("MHN", "4th"),
                        c("MUN", "MHO"), c("MUN", "MUO"), c("MHO", "MUO"))
alpha <- create_alpha_plots(ps_obj,col = 'phenotype',measure = measure,method = method ,color = colors,my_comparisons= my_comparisons,size=15,level_factors= c("MHN","MUN","MHO","MUO"))

size <- c(3,2)
figure <- ggarrange(beta,alpha,nrow=1, widths = size,labels = c('A', 'B'))
figure
figure[[1]]
as.factor(ps_obj@sam_data$batch)
#ggsave("./figures/alpha_beta_Genus.png",figure,dpi=300,height = 10,width=15)

```
#alpha
```{r,fig.height=4,fig.width=6}
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'compositional',detection = 10,prev = 0.05,taxonomic_level = 'taxa_names',
                                     first = 'filter')
?octobiom::create_alpha_plots
#Let's analyze alpha diversity
features <- c('phenotype','batch')#,'sex',
              #"smoking_status","YEAR" )
color_palette <- octobiom::get_palette("set_10_4")
plot_alpha_list <- purrr::map(features, ~ {
  tryCatch({
    octobiom::create_alpha_plots(ps_obj, col= .x, colors = color_palette,measure = c("Shannon",'Simpson'))
  }, error = function(e) {
    message(paste("Error in method:", .x))
    message(e$message)  # Print the error message
    return(NULL)  # Return NULL for this iteration
  })
})
plot_alpha_list_chao <- purrr::map(features, ~ {
  tryCatch({
    octobiom::create_alpha_plots(ps, col= .x, colors = color_palette,measure = c("Chao1"))
  }, error = function(e) {
    message(paste("Error in method:", .x))
    message(e$message)  # Print the error message
    return(NULL)  # Return NULL for this iteration
  })
})
plot_alpha_list_chao
plot_alpha_list

ggpubr::ggarrange(plot_alpha_list[[1]]$plots,plot_alpha_list_chao[[1]]$plots,widths = c(2,1))
ggpubr::ggarrange(plot_alpha_list[[2]]$plots,plot_alpha_list_chao[[2]]$plots,widths = c(2,1))
p.adjust(plot_alpha_list[[1]]$stats$Shannon$p,method = 'BH')
```
# dmm
```{r,fig.width=10}
source("./code/DMM.R")
ps_obj <- ps
ps_obj <- subset_samples(ps_obj, 
                               !is.na(sample_data(ps_obj)$cancer) &
                               !is.na(sample_data(ps_obj)$liver_diseases) &
                               !is.na(sample_data(ps_obj)$dietary_quality_score_cat) &
                                 !is.na(sample_data(ps_obj)$total_phys_act_index)
                         )
meta <- as(ps_obj@sam_data,'data.frame')
meta <- meta %>%
  dplyr::mutate(phenotype = recode(phenotype,
                             `1st` = "MHN",
                             `2nd` = "MUN",
                             `3rd` = "MHO",
                             `4th` = "MUO"))
ps_obj@sam_data <- sample_data(meta)
level <- 'Genus'
det <- 1
prev<-5/100
ps_obj <- speedyseq::tax_glom(ps_obj,taxrank = level, NArm=T )
taxas <- core_members(ps_obj, detection = det, prevalence = prev, include.lowest = F)
ps_obj <- prune_taxa(taxas, ps_obj)
tt <- as(tax_table(ps), 'matrix') # need species
tt <- as.data.frame(tt)
tt$OTU <- row.names(tt)
tt$plot <- paste(row.names(tt), tt$Genus,tt$Species, sep = '__')
palette <- colors

dat <- abundances(ps_obj)
count <- as.matrix(t(dat))
fit=mclapply(1:10, dmn, count = count, mc.cores = 30)
lplc <- sapply(fit, laplace) # AIC / BIC / Laplace
aic  <- sapply(fit, AIC) # AIC / BIC / Laplace
bic  <- sapply(fit, BIC) # AIC / BIC / Laplace
size=15
df <- do.call(rbind, Map(data.frame, lplc=lplc, aic=aic, bic=bic, num=c(1:length(lplc))))
lap <- ggplot(data=df, aes(x = num))+
    geom_line(aes(y = lplc), color = "#33608CFF") + 
    geom_point(aes(y = lplc)) +
    geom_line(aes(y = aic), color="#F2994EFF", linetype="twodash") +
    geom_point(aes(y = aic)) +
    geom_line(aes(y = bic), color="#B81840FF", linetype="twodash") +
    geom_point(aes(y = bic)) +
    scale_color_identity(name = '',
                         breaks = c('#33608CFF', '#F2994EFF', '#B81840FF'),
                         labels = c("lplc", "aic", "bic"),
                         guide = 'legend')+
    ggtitle('Fit for diffrent Dirichlet Components number') +
    xlab("Number of Dirichlet Components") + ylab("Model Fit")+ theme1
  # ggsave(plot=p, path=wd_path, filename='Fit for diffrent Dirichlet Components number.pdf', device='pdf', width = 7, height = 5)
lap
column_combinations <- list(
      c( "best","phenotype")# Define combinations of columns for plotting
    )
ps_obj@sam_data$phenotype <- factor(ps_obj@sam_data$phenotype,level = c("MHN","MUN","MHO","MUO"))
#best <- fit[[which.min(unlist(lplc))]]
#print(best)
# We want to choose k = 4
best <- fit[[4]]

source("./code/DMM.R")
plots_dmm <- create_dmm_plot(ps_obj,fit,best,column_combinations= column_combinations,palette = colors ,tt=tt,annotation_table = F)
print(plots_dmm)
ps@tax_table['ASV12','Species']

```
# Biochem disrtibution in dmm's cluster
```{r,fig.width =20,fig.height = 10}
asss <- mixture(best, assign = TRUE)
sample_data(ps_obj)$best <- as.factor(asss)
  
ps_meta <- as(sample_data(ps_obj), 'data.frame')
cols_to_keep<- c("alanine_transanimase_U.L",                                  "apolipoprotein_A1_g.L",                                    
 "apolipoprotein_B_g.L" ,                                    
 "aspartate_transanimase_U.L",                               
 "total_cholesterol_mmol.L",                                 
"serum_creatinine_micromol.L",                              
"urine_creatinine_micromol.L" ,                             
 "hs.CRP_mg.L",                                              
"cystatin_C_mg.L",                                         
"GGT_U.L",                                                  
 "HbA1c_mol" ,                                               
"HDL_cholesterol_mmol.L",                                   
"LDL_cholesterol.mmol.L",                                   
"Lp_a_mg.dl",                                               
 "urine_albumin_mg.L" ,                                      
 "haemoglobin_mol",                                        
 "transferrin_g.L"  ,                                        
 "triglycerides_mmol.L" ,                                   
 "HbA1C_.")



for (i in seq_along(cols_to_keep)) {
  cols <- cols_to_keep[i]  
  ps_meta[[cols]] <- as.numeric(ps_meta[[cols]])
}

ps_meta$log_alanine_transanimase_U.L <- log10(ps_meta$alanine_transanimase_U.L)
ps_meta$log_hs.CRP_mg.L <- log10(ps_meta$hs.CRP_mg.L)
ps_meta$log_GGT_U.L <- log10(ps_meta$GGT_U.L)
ps_meta$log_triglycerides_mmol.L <- log10(ps_meta$triglycerides_mmol.L)

new_element <- c("log_alanine_transanimase_U.L",'log_hs.CRP_mg.L','log_GGT_U.L','log_triglycerides_mmol.L')
cols_to_keep <- c(new_element)

my_comparisons <- list(c('1','2'),c('1','3'),c('1','4'),
                       c('2','3'),c('2','4'),c('3','4'))

palette <- pnw_palette("Bay", n=4)
plot_list <- list()
# Loop through cols_to_keep if needed
for (i in seq_along(cols_to_keep)) {
  cols <- c('best', cols_to_keep[i])  # Dynamically create column names
  #cols <- c('phenotype',cols_to_keep[i])
  
  # Check if columns exist
  if (!all(cols %in% colnames(ps_meta))) {
    stop(paste("Columns not found in ps_meta:", paste(cols[!cols %in% colnames(ps_meta)], collapse = ", ")))
  }
  size <- 14
  
  anno_df <- ggpubr::compare_means(as.formula(paste(cols[[2]]," ~", cols[[1]])), data = ps_meta, method = "wilcox.test",p.adjust.method = "BH")%>%
    add_significance("p.adj") %>%
    add_x_position()%>%
    add_y_position( data=ps_meta,formula = as.formula(paste(cols[2]," ~", cols[1])),step.increase = 0.2)

  # Create the plot
  plot_list[[cols[2]]] <- ggplot(ps_meta, aes_string(x = cols[[1]], y = cols[[2]], color = cols[[1]])) +
    geom_violin(trim = FALSE, alpha = 0.1) +
    geom_boxplot(width = 0.5, alpha = 0.75, position = position_dodge(0.9)) +
    geom_jitter(size = 1.5, alpha = 0.5, position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.9)) +
    scale_color_manual(values = colors) +
    theme_minimal()+
    #theme_bw(base_size = 20) +
    theme(
      plot.title = element_text(color = "black", size = size),
      axis.text.y = element_text(color = "black", size = size),
      axis.text.x = element_text(angle = 90, hjust = 1, size = 15, color = 'black'),
      legend.position = "none",
      axis.title.y = element_text(color = "black", size = size, angle = 90),
      axis.title.x = element_text(color = "black", size = size),
      text = element_text(size = size, colour ='black')
    )+
    ggtitle(paste0(cols[2]))+
    stat_pvalue_manual(
    anno_df,  label = "p.adj.signif", tip.length = 0.02,
    step.increase = 0.05,coord.flip = FALSE
  )
  
}


p<- ggarrange(plot_list[[1]],plot_list[[2]],plot_list[[3]],plot_list[[4]],ncol=2,nrow=2)

create_plot_rel <- function(cols, palette,ps_meta) {
  dataex <- ps_meta %>%
    dplyr::group_by_at(cols) %>%
    dplyr::summarise(N = n()) %>%
    dplyr::mutate(rel_count = N / sum(N)) 
  
  # Perform chi-squared test
  chisq_result <- chisq.test(ps_meta[[cols[1]]], ps_meta[[cols[2]]])
  chisq_pvalue <- format(chisq_result$p.value, digits = 3)
  
  ggplot(dataex, aes(x = !!sym(cols[[1]]), y = rel_count, fill = !!sym(cols[[2]]))) +
    geom_bar(position = "stack", stat = "identity") +
    geom_text(aes(label = scales::percent(rel_count, accuracy = 1)), position = position_stack(vjust = 0.5), size = 6)  +
    labs(title = paste("Chi-squared p-value:", chisq_pvalue ), fill = cols[[2]]) +
    scale_fill_manual(values = colors) +
    theme_linedraw()
}
palette <- pnw_palette("Spring", n=5)
age_dmm <- create_plot_rel(c('best','age_at_heath_check_10yr'),colors,ps_meta)
sex_dmm <-create_plot_rel(c('best','sex'),colors,ps_meta)
batch_dmm <- create_plot_rel(c('best','batch'),colors,ps_meta)
smoke_dmm <- create_plot_rel(c('best','current_smoker'),colors,ps_meta)
drink_dmm <- create_plot_rel(c('best','drinking_level'),colors,ps_meta)
drink_dmm
#year_dmm <- create_plot_rel(c('best','YEAR'),colors,ps_meta)

p <- p + ( age_dmm/ sex_dmm/batch_dmm/drink_dmm) + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(size=14,face="bold") )
p
#ggsave('./figures/biochem_distribution_dmm_clusters.png',p,dpi=300,width=20,height = 15)

create_plot_rel(c('phenotype','smoking_status'),colors,ps_meta)

```
#biochem_distribution sample group
```{r,fig.width=15,fig.height=15}
ps_meta <- as(sample_data(ps), 'data.frame')
cols_to_keep<- c("alanine_transanimase_U.L",                                  "apolipoprotein_A1_g.L",                                    
 "apolipoprotein_B_g.L" ,                                    
 "aspartate_transanimase_U.L",                               
 "total_cholesterol_mmol.L",                                 
"serum_creatinine_micromol.L",                              
"urine_creatinine_micromol.L" ,                             
 "hs.CRP_mg.L",                                              
"cystatin_C_mg.L",                                         
"GGT_U.L",                                                  
 "HbA1c_mol" ,                                               
"HDL_cholesterol_mmol.L",                                   
"LDL_cholesterol.mmol.L",                                   
"Lp_a_mg.dl",                                               
 "urine_albumin_mg.L" ,                                      
 "haemoglobin_mol",                                        
 "transferrin_g.L"  ,                                        
 "triglycerides_mmol.L" ,                                   
 "HbA1C_.")
for (i in seq_along(cols_to_keep)) {
  cols <- cols_to_keep[i]  
  ps_meta[[cols]] <- as.numeric(ps_meta[[cols]])
}

ps_meta$log_alanine_transanimase_U.L <- log10(ps_meta$alanine_transanimase_U.L)
ps_meta$log_hs.CRP_mg.L <- log10(ps_meta$hs.CRP_mg.L)
ps_meta$log_GGT_U.L <- log10(ps_meta$GGT_U.L)
ps_meta$log_cystatin_C_mg.L <- log10(ps_meta$cystatin_C_mg.L)
ps_meta$log_triglycerides_mmol.L <- log10(ps_meta$triglycerides_mmol.L)
ps_meta$log_triglycerides_mmol.L

cols_to_keep <- c('log_GGT_U.L','log_hs.CRP_mg.L','triglycerides_mmol.L',
                  'log_alanine_transanimase_U.L','HDL_cholesterol_mmol.L', 
                  'LDL_cholesterol.mmol.L','HbA1c_mol' ,
                  'log_cystatin_C_mg.L','apolipoprotein_A1_g.L', 'apolipoprotein_B_g.L')

cols_to_keep <- c('log_triglycerides_mmol.L',
                  'HDL_cholesterol_mmol.L', 
                  'HbA1C_.' ,'log_hs.CRP_mg.L')#,'log_GGT_U.L')
colnames_biochem <- c('log(TG), mmol/L','HDL-C, mmol/L','HbA1c, %',
                      'log(CRP), mg/L')#,'log(GGT), U/L')

my_comparisons <- list(c('1st','2nd'),c('1st','3rd'),c('1st','4th'),
                       c('2nd','3rd'),c('2nd','4th'),c('3rd','4th'))
plot_list <- list()
palette <- pnw_palette("Bay", n=4)
for (i in seq_along(cols_to_keep)) {
  cols <- c('phenotype', cols_to_keep[i])  # Dynamically create column names
  #cols <- c('phenotype',cols_to_keep[i])
  
  # Check if columns exist
  if (!all(cols %in% colnames(ps_meta))) {
    stop(paste("Columns not found in ps_meta:", paste(cols[!cols %in% colnames(ps_meta)], collapse = ", ")))
  }
  size <- 12
  
  anno_df <- ggpubr::compare_means(as.formula(paste(cols[[2]]," ~", cols[[1]])), data = ps_meta, method = "wilcox.test",p.adjust.method = "BH"
                                   )%>%
    add_significance("p.adj") %>%
    add_x_position()%>%
    add_y_position( data=ps_meta,formula = as.formula(paste(cols[2]," ~", cols[1])),step.increase = 0.2)

  # Create the plot
  plot_list[[cols[2]]] <- ggplot(ps_meta, aes_string(x = cols[[1]], y = cols[[2]], color = cols[[1]])) +
    geom_violin(trim = FALSE, alpha = 0.1) +
    geom_boxplot(width = 0.5, alpha = 0.75, position = position_dodge(0.9)) +
    geom_jitter(size = 1.5, alpha = 0.5, position = position_jitterdodge(jitter.width = 0.1, dodge.width = 0.9)) +
    scale_color_manual(values = palette) +
    theme_minimal()+
    #theme_bw(base_size = 20) +
    theme(
      plot.title = element_text(color = "black", size = size,hjust = 0.5, face = "bold"),
      axis.text.y = element_text(color = "black", size = size),
      axis.text.x = element_text(angle = 0, hjust = 1, size = 15, color = 'black'),
      legend.position = "none",
      axis.title.y = element_text(color = "black", size = size, angle = 90),
      axis.title.x = element_text(color = "black", size = size),
      text = element_text(size = size, colour ='black')
    )+
    ggtitle(paste0(colnames_biochem[i]))+
    stat_pvalue_manual(
    anno_df,  label = "p.adj.signif", tip.length = 0.02,
    step.increase = 0.05,coord.flip = FALSE
  )+
    scale_x_discrete(labels = c('1st'='MHN','2nd'='MUN','3rd'='MHO','4th'='MUO'))
}

plot_list[3]
#+ ggtitle('HbA1c, %')
p <- ggarrange(plotlist = plot_list,nrow=2,ncol=2)
p

#ggsave("./figures/figure_1b.png",p,dpi=300,height = 9,width=9)

```
#dmm_beta
```{r, fig.width=23,fig.height=12}
trans <- 'compositional'
ps_obj_comp <- microbiome::transform(ps_obj, trans)
distance_method <- 'bray' 

beta_dmm <- create_ordination_plots(ps_obj_comp, method = "PCoA", distance_method = distance_method , group = "best", size = 15,palette=colors,level_factors = c('1','2','3','4','5','6'))


dmm_1 <- ggarrange(ggarrange(beta_dmm,labels='A'),plots_dmm,ncol=2,common.legend = F)
dmm_1
ggarrange(beta_dmm,labels='A') | plots_dmm
print(plots_dmm)
#ggsave("./figures/dmm_beta.png",p,dpi=300,height = 13,width=23)

```
#top drivers + phenotype + batch

```{r, fig.width=20,fig.height=20}
best_list <- list(best) 
size = 20
tt <- as(tax_table(ps_obj), 'matrix')
tt <- as.data.frame(tt)
table(tt$Family)
tt$OTU <- row.names(tt)
tt$plot <- paste(row.names(tt),tt$Genus, sep = '__')#tt$OTU, tt$Family,tt$Species
pp <- list()
for (b in best_list){
  for (k in seq(ncol(fitted(b)))) {
  d <- melt(fitted(b))
  colnames(d) <- c("OTU", "cluster", "value")

  d <- subset(d, cluster == k) %>%
     # Arrange OTUs by assignment strength
     arrange(value) %>%
     mutate(OTU = factor(OTU, levels = unique(OTU)))   %>%
    filter(abs(value) > quantile(abs(value), 0.95
                                 ))  
  
  mm <- merge(tt, d, by = 'OTU')
  mm <- mm[order(-mm$value),]
  
  p <- ggplot(data=mm, aes(x=reorder(plot, value), y=value, fill=Phylum)) +
  geom_bar(stat="identity") +
  theme_minimal() +
  coord_flip() +
  ggtitle(paste('best Number: ', k)) +
  scale_fill_manual(values = paletteer_c("ggthemes::Sunset-Sunrise Diverging", 3)) +
  labs(x='taxa') +
  theme(
    axis.title.y = element_text(size = 15, color = "black"),
    axis.title.x = element_text(size = 15, color = "black"),
    axis.text = element_text(color = "black", size = 10),
    plot.title = element_text(size = 20, color = "black"),
     legend.text = element_text(size = 10),  # Increase legend text size
    legend.title = element_text(size = 15) 
  )
  # print(p)
  pp[[k]] <- p
  # ggsave(plot=p, path='./tip', filename=paste("top_drivers: ", k, '.pdf'), device='pdf', width = 10, height = 13)
}
# pp <-do.call(grid.arrange,pp)
grid.arrange(grobs=pp, nrow=3)
  
}
ps_meta$phenotype <- factor(ps_meta$phenotype,level = c('MHN','MUN','MHO','MUO'))
create_plot_rel <- function(cols, palette,ps_meta) {
  dataex <- ps_meta %>%
    dplyr::group_by_at(cols) %>%
    dplyr::summarise(N = n()) %>%
    dplyr::mutate(rel_count = N / sum(N)) 
  
  # Perform chi-squared test
  chisq_result <- chisq.test(ps_meta[[cols[1]]], ps_meta[[cols[2]]])
  chisq_pvalue <- format(chisq_result$p.value, digits = 3)
  
  ggplot(dataex, aes(x = !!sym(cols[[1]]), y = rel_count, fill = !!sym(cols[[2]]))) +
    geom_bar(position = "stack", stat = "identity") +
    geom_text(aes(label = scales::percent(rel_count, accuracy = 1)), position = position_stack(vjust = 0.5), size = 6)  +
    labs(title = paste("Chi-squared p-value:", chisq_pvalue ), fill = cols[[2]]) +
    scale_fill_manual(values = colors) +
    theme_linedraw()+ 
    guides(fill=guide_legend(title='Enterotype'))+
    # Adjust font size of x-axis labels
    theme(axis.text.x = element_text(size = 10),
          axis.text.y = element_text(size=10),
          legend.box.margin = margin(l = 0, unit = "cm"))
}
#palette <- pnw_palette("Spring", n=5)
phenotype_dmm <- create_plot_rel(c('phenotype','best'),colors,ps_meta)
phenotype_dmm 
batch_dmm <- create_plot_rel(c('batch','best'),colors,ps_meta)
batch_dmm

p_top_taxa <- ((pp[[1]] + pp[[2]]) /      # First row with plots from pp
               (pp[[3]] + pp [[4]]))# /
                  #(pp[[5]] + pp[[6]]))# Second row with more plots from pp
               
entero <- (phenotype_dmm / batch_dmm)           # Stack age_dmm over batch_dmm


#final_plot <- (ggarrange(beta_dmm,labels='A') | ggarrange(plots_dmm,labels = 'B') ) /
#                ggarrange(p_top_taxa,entero,widths = c(1,1),labels =c("C","D")) 
final_plot <-
ggarrange(beta_dmm,p_top_taxa,ncol=1,nrow=2)|(plots_dmm/entero) 
#final_plot <- (ggarrange(beta_dmm,labels='A') | ggarrange(plots_dmm,labels = 'B') ) /
#                ggarrange((phenotype_dmm | batch_dmm),widths = c(1,1),labels =c("C","D")) +plot_layout(heights = c(2,1))
# Отображаем финальный график

plot(final_plot)    
# pp
ggsave("./figures/dmm_beta.png",final_plot,dpi=300,height = 16
       ,width=24)
# heatmapdmn
```

#Create a list of subsets to network
```{r}
ps_obj <- ps
level <- 'Genus'
year='2017 16S'
det <- 1
prev<-10/100

ps_obj <- speedyseq::tax_glom(ps_obj,taxrank = level, NArm=T )
taxas <- core_members(ps_obj, detection = det, prevalence = prev, include.lowest = F)
ps_obj <- prune_taxa(taxas, ps_obj)

meta <- as(ps_obj@sam_data,'data.frame')
meta <- meta %>%
  dplyr::mutate(phenotype = recode(phenotype,
                             `1st` = "MHN",
                             `2nd` = "MUN",
                             `3rd` = "MHO",
                             `4th` = "MUO"))
ps_obj@sam_data <- sample_data(meta)

# Manually create the subsets
ps_obj_1st <- phyloseq::subset_samples(ps_obj, sample_data(ps_obj)$phenotype == "MHN")
count_mtrx_1st <- prepare_count_table(ps_obj_1st, taxa_name_func)
taxa_names(ps_obj_1st) <- colnames(count_mtrx_1st)
otu_table(ps_obj_1st) <- otu_table(count_mtrx_1st, taxa_are_rows = FALSE)

ps_obj_2nd <- phyloseq::subset_samples(ps_obj, sample_data(ps_obj)$phenotype == "MUN")
count_mtrx_2nd <- prepare_count_table(ps_obj_2nd, taxa_name_func)
taxa_names(ps_obj_2nd) <- colnames(count_mtrx_2nd)
otu_table(ps_obj_2nd) <- otu_table(count_mtrx_2nd, taxa_are_rows = FALSE)

ps_obj_3rd <- phyloseq::subset_samples(ps_obj, sample_data(ps_obj)$phenotype == "MHO")
count_mtrx_3rd <- prepare_count_table(ps_obj_3rd, taxa_name_func)
taxa_names(ps_obj_3rd) <- colnames(count_mtrx_3rd)
otu_table(ps_obj_3rd) <- otu_table(count_mtrx_3rd, taxa_are_rows = FALSE)

ps_obj_4th <- phyloseq::subset_samples(ps_obj, sample_data(ps_obj)$phenotype == "MUO")
count_mtrx_4th <- prepare_count_table(ps_obj_4th, taxa_name_func)
taxa_names(ps_obj_4th) <- colnames(count_mtrx_4th)
otu_table(ps_obj_4th) <- otu_table(count_mtrx_4th, taxa_are_rows = FALSE)

count_mtrx <- prepare_count_table(ps_obj, taxa_name_func)
taxa_names(ps_obj) <- colnames(count_mtrx)
otu_table(ps_obj) <- otu_table(count_mtrx, taxa_are_rows = FALSE)

#ps_obj_healthy <- phyloseq::subset_samples(ps_obj, sample_data(ps_obj)$bmi_group #== "Healthy")
#count_mtrx_healthy <- prepare_count_table(ps_obj_healthy, taxa_name_func)
#taxa_names(ps_obj_healthy) <- colnames(count_mtrx_healthy)
#otu_table(ps_obj_healthy) <- otu_table(count_mtrx_healthy, taxa_are_rows = FALSE)
#
#ps_obj_obesity <- phyloseq::subset_samples(ps_obj, sample_data(ps_obj)$bmi_group #== "Obesity")
#count_mtrx_obesity <- prepare_count_table(ps_obj_obesity, taxa_name_func)
#taxa_names(ps_obj_obesity) <- colnames(count_mtrx_obesity)
#otu_table(ps_obj_obesity) <- otu_table(count_mtrx_obesity, taxa_are_rows = FALSE)
#
#phenotype_subsets <- list("Healthy" = ps_obj_healthy, "Obesity" = ps_obj_obesity #)
#
# Create a list of the subsets
phenotype_subsets <- list("MHN" = ps_obj_1st, "MUN" = ps_obj_2nd, "MHO" = ps_obj_3rd, "MUO" = ps_obj_4th)
```

# Define a function to construct and analyze network
```{r}
construct_analyze_networks <- function(ps_obj) {
    
  # Construct the network using NetCoMi
    net_spring2 <- netConstruct(data = ps_obj,
                                measure = "spieceasi",
                                measurePar = list(nlambda = 25, 
                                                  method = "mb",
                                                  pulsar.params = list(rep.num = 100, subsample.ratio = 0.8, thresh = 0.025, ncores = 30),
                                                  lambda.min.ratio = 1e-3),
                                normMethod = "none", 
                                zeroMethod = "none",
                                sparsMethod = "none", 
                                dissFunc = "signed",
                                verbose = 2,
                                seed = 12345)
    
    # Analyze the network properties
    props_season1 <- netAnalyze(net_spring2, 
                                centrLCC = FALSE,
                                avDissIgnoreInf = TRUE,
                                sPathNorm = FALSE,
                                clustMethod = "cluster_louvain",
                                hubPar = c('degree', "eigenvector"),
                                hubQuant = 0.95,
                                lnormFit = TRUE,
                                normDeg = FALSE,
                                normBetw = FALSE,
                                normClose = FALSE,
                                normEigen = FALSE)
    
  # Return the list of network analysis results
  return(props_season1)
}
network_analysis_results <- construct_analyze_networks(ps_obj)

```

```{r, fig.width=70, fig.height=30}
# Define the visualization function
visualize_network_analysis <- function(props_season1) {
  
  props_season1 <- props_season1
    
  # Optionally, you can also save the plots
  pdf_filename <- paste0("./figures/network_plot.pdf")
  #pdf_filename <- paste0("~/DAVID_WGS/different_figures/network_plot.pdf")
  pdf(pdf_filename, width = 100, height = 50) 
  plot(props_season1, 
         sameLayout = TRUE, 
         layoutGroup = "union",
         hubBorderCol = "gray40",
         nodeColor = "cluster", 
         posCol = "purple", 
         negCol = "darkturquoise",
         rmSingles = "inboth", 
         nodeSize = "eigenvector", 
         labelScale = FALSE,
         cexNodes = 1.5, 
         cexLabels = 3,
         cexHubLabels = 6,
         cexTitle = 9)
    
    legend("bottom", title = "estimated association:", legend = c("+", "-"), 
           col = c("purple", "darkturquoise"), inset = 0.2, cex = 0.1, lty = 1, lwd = 0.5, 
           bty = "n", horiz = TRUE)
    
    # Close PDF device
  dev.off()
    
    # Check if the file has been created
  if (file.exists(pdf_filename)) {
    message(paste("Successfully saved plot:", pdf_filename))
  } else {
    warning(paste("Failed to save plot:", pdf_filename))
  }
}


# Example usage
visualize_network_analysis(network_analysis_results)

```
# Define a function to construct and analyze groups networks
```{r}
construct_analyze_networks <- function(phenotype_subsets) {
  # Get the names of the phenotype subsets
  phenotype_names <- names(phenotype_subsets)
  
  # Create a list of all unique pairwise combinations
  combinations <- combn(phenotype_names, 2, simplify = FALSE)
  
  # Create an empty list to store the results
  network_analysis_results <- list()
  
  # Loop over all pairwise combinations of phenotype subsets
  for (comb in combinations) {
    phenotype1 <- comb[1]
    phenotype2 <- comb[2]
    
    ps_obj_1 <- phenotype_subsets[[phenotype1]]
    ps_obj_2 <- phenotype_subsets[[phenotype2]]
    
    # Construct the network using NetCoMi
    net_spring2 <- netConstruct(data = ps_obj_1,
                                data2 = ps_obj_2,
                                filtTax = "highestFreq",
                                filtTaxPar = list(highestFreq = 250),
                                measure = "spieceasi",
                                measurePar = list(nlambda = 25, 
                                                  method = "mb",
                                                  pulsar.params = list(rep.num = 100, subsample.ratio = 0.8, thresh = 0.025, ncores = 30),
                                                  lambda.min.ratio = 1e-3),
                                normMethod = "none", 
                                zeroMethod = "none",
                                sparsMethod = "none", 
                                dissFunc = "signed",
                                verbose = 2,
                                seed = 12345
                                )
    
    # Analyze the network properties
    props_season1 <- netAnalyze(net_spring2, 
                                centrLCC = FALSE,
                                avDissIgnoreInf = TRUE,
                                sPathNorm = FALSE,
                                clustMethod = "cluster_louvain",
                                hubPar = c('degree', "eigenvector"),
                                hubQuant = 0.95,
                                lnormFit = TRUE,
                                normDeg = FALSE,
                                normBetw = FALSE,
                                normClose = FALSE,
                                normEigen = FALSE)
    
    # Store the result in the list
    combination_name <- paste(phenotype1, "vs", phenotype2, sep = "_")
    network_analysis_results[[combination_name]] <- props_season1
  }
  
  # Return the list of network analysis results
  return(network_analysis_results)
}
network_analysis_results <- construct_analyze_networks(phenotype_subsets)
```

```{r}
visualize_network_analysis <- function(network_analysis_results, cex_value = 1.5) {
  summaries_list <- list()  # Initialize an empty list to store summaries
  
  for (combination_name in names(network_analysis_results)) {
    props_season1 <- network_analysis_results[[combination_name]]

    # Save the summary of props_season1 in the list
    summary_props <- summary(props_season1)

    # Replace 'group 1' and 'group 2' in the summaries with actual names from combination
    group_names <- strsplit(combination_name, "_vs_")[[1]]  # Extract group names from combination

    #if (!is.null(summary_props[["glob_probs"]])) {
    #  colnames(summary_props[["glob_probs"]]) <- group_names  # Replace column names for glob_probs_lcc
    #}

    # Save the modified summary back to the summaries_list
    summaries_list[[combination_name]] <- summary_props
    #pdf(pdf_filename, width = 100, height = 50) 
    # Optionally, you can also save the plots
    pdf_filename <- paste0("./figures/network_plot__paper_", combination_name, ".pdf")
    pdf(pdf_filename, width = 100, height = 50) 
    #pdf(pdf_filename, width = 100, height = 50, units="in", res=300) 
    
    
    plot(props_season1, 
     sameLayout = TRUE, 
     layoutGroup = "union",
     hubBorderCol = "gray40",
     nodeColor = "cluster", 
     posCol = "purple", 
     negCol = "darkturquoise",
     rmSingles = "inboth", 
     nodeSize = "eigenvector", 
     labelScale = FALSE,
     cexNodes = 1, 
     cexLabels = 2.5,
     cexHubLabels = 5,
     cexTitle = 9,
     groupNames = group_names)

# Extract Modularity, Natural Connectivity, and other metrics from glob_probs_lcc
if (!is.null(summary_props[["glob_probs"]])) {
  glob_probs_lcc <- summary_props[["glob_probs"]]
  
  # Extract the required values, rounding to 3 decimal places
  modularity <- round(glob_probs_lcc["Modularity", ], 3)
  natural_connectivity <- round(glob_probs_lcc["Natural connectivity", ], 3)
  num_components <- round(glob_probs_lcc["Number of components", ], 3)
  positive_edge_percentage <- round(glob_probs_lcc["Positive edge percentage", ], 3)
  edge_density <- round(glob_probs_lcc["Edge density", ], 3)
  clustering_coefficient <- round(glob_probs_lcc["Clustering coefficient", ], 3)

  # Adjust the closeness of table elements by reducing spacing
  table_x <- -0.05 # X coordinate for the table (left of the plot)
  table_y <- 1.2   # Y coordinate for the table (above the plot)
  row_spacing <- 0.05  # Adjust this to make rows closer (smaller values bring rows closer)
  col_spacing <- 0.1  # Adjust this to make columns closer (smaller values bring columns closer)

  # Column headers (group names)
  text(x = table_x + col_spacing, y = table_y, labels = group_names[1], cex = cex_value, font = 2)
  text(x = table_x + 2 * col_spacing, y = table_y, labels = group_names[2], cex = cex_value, font = 2)
  
  # Row 1: Modularity
  text(x = table_x - 0.05, y = table_y - row_spacing, labels = "Modularity", cex = cex_value, font = 2)
  text(x = table_x + col_spacing, y = table_y - row_spacing, labels = modularity[1], cex = cex_value)
  text(x = table_x + 2 * col_spacing, y = table_y - row_spacing, labels = modularity[2], cex = cex_value)
  
  # Row 2: Natural Connectivity
  text(x = table_x - 0.05, y = table_y - 2 * row_spacing, labels = "Natural connectivity", cex = cex_value, font = 2)
  text(x = table_x + col_spacing, y = table_y - 2 * row_spacing, labels = natural_connectivity[1], cex = cex_value)
  text(x = table_x + 2 * col_spacing, y = table_y - 2 * row_spacing, labels = natural_connectivity[2], cex = cex_value)

  # Row 3: Number of Components
  text(x = table_x - 0.05, y = table_y - 3 * row_spacing, labels = "Number of components", cex = cex_value, font = 2)
  text(x = table_x + col_spacing, y = table_y - 3 * row_spacing, labels = num_components[1], cex = cex_value)
  text(x = table_x + 2 * col_spacing, y = table_y - 3 * row_spacing, labels = num_components[2], cex = cex_value)

  # Row 4: Positive Edge Percentage
  text(x = table_x - 0.05, y = table_y - 4 * row_spacing, labels = "Positive edge percentage", cex = cex_value, font = 2)
  text(x = table_x + col_spacing, y = table_y - 4 * row_spacing, labels = positive_edge_percentage[1], cex = cex_value)
  text(x = table_x + 2 * col_spacing, y = table_y - 4 * row_spacing, labels = positive_edge_percentage[2], cex = cex_value)

  # Row 5: Edge Density
  text(x = table_x - 0.05, y = table_y - 5 * row_spacing, labels = "Edge density", cex = cex_value, font = 2)
  text(x = table_x + col_spacing, y = table_y - 5 * row_spacing, labels = edge_density[1], cex = cex_value)
  text(x = table_x + 2 * col_spacing, y = table_y - 5 * row_spacing, labels = edge_density[2], cex = cex_value)

  # Row 6: Clustering Coefficient
  text(x = table_x - 0.05, y = table_y - 6 * row_spacing, labels = "Clustering coefficient", cex = cex_value, font = 2)
  text(x = table_x + col_spacing, y = table_y - 6 * row_spacing, labels = clustering_coefficient[1], cex = cex_value)
  text(x = table_x + 2 * col_spacing, y = table_y - 6 * row_spacing, labels = clustering_coefficient[2], cex = cex_value)
}

    
    # Close PDF device
    dev.off()
    
    # Check if the file has been created
    #if (file.exists(pdf_filename)) {
    #  message(paste("Successfully saved plot:", pdf_filename))
    #} else {
    #  warning(paste("Failed to save plot:", pdf_filename))
    #}
  }
  
  # Return the list of summaries after the loop finishes
  return(summaries_list)
}

# Example usage with adjustable cex
summaries <- visualize_network_analysis(network_analysis_results, cex_value = 4.25)

# Print summaries (or part of them for a large output)
print(summaries)

names(network_analysis_results)


```
#Supp
```{r,fig.width=15,fig.height=10}
ps_obj <- ps
ps_obj@sam_data$bmi_group
ps_obj <- subset_samples(ps_obj, 
                               !is.na(sample_data(ps_obj)$cancer) &
                               !is.na(sample_data(ps_obj)$liver_diseases) &
                               !is.na(sample_data(ps_obj)$dietary_quality_score_cat) &
                                 !is.na(sample_data(ps_obj)$total_phys_act_index)                         )
meta <- as(ps_obj@sam_data,'data.frame')
meta <- meta %>%
  dplyr::mutate(phenotype = recode(phenotype,
                             `1st` = "MHN",
                             `2nd` = "MUN",
                             `3rd` = "MHO",
                             `4th` = "MUO"))
ps_obj@sam_data <- sample_data(meta)
#level <- 'Genus'
year <- '2017 16S'
det <- 1
prev<-10/100

ps_obj@sam_data$phenotype <- factor(ps_obj@sam_data$phenotype,levels =  c("MHN","MUN","MHO","MUO"))
ps_obj <- speedyseq::tax_glom(ps_obj,taxrank = level, NArm=T )
taxas <- core_members(ps_obj, detection = det, prevalence = prev)
ps_obj <- prune_taxa(taxas, ps_obj)
ps_obj@sam_data$age <- ps_obj@sam_data$age_at_heath_check_10yr
ps_obj@sam_data$ISCO <- ps_obj@sam_data$ISCO_group
ps_obj@sam_data$diet_quality <- ps_obj@sam_data$dietary_quality_score_cat
ps_obj@sam_data$physical_activity <- ps_obj@sam_data$total_phys_act_index

ps_meta <- as(sample_data(ps_obj), 'data.frame')

cols_meta <- data.frame(
  category = c('technical','sociodemographic','sociodemographic','sociodemographic','self-reported\n chronic diseases','self-reported\n chronic diseases','behavioral\n factors','behavioral\n factors',
            'self-reported\n chronic diseases','sociodemographic','sociodemographic','behavioral\n factors'), 
  row.names = c( "batch", "sex",'age','education','cancer','kidney_disease','drinking_level',
                  'diet_quality' , 
                  'diabetes','physical_activity','ISCO','smoking_status'))
#cols_meta$new_name <- rownames(cols_meta)
category_order <- c('sociodemographic','behavioral\n factors', 'self-reported\n chronic diseases','technical')

# Reorder the factor levels in cols_meta
cols_meta$category <- factor(cols_meta$category, levels = category_order)

sorted_cols_meta <- cols_meta %>%
  arrange(category)

colors_category <- c(
  'sociodemographic' = '#a100bf',
  'self-reported\n chronic diseases' ='#bf4380',
  'technical'='#1d8dcf',
  'behavioral\n factors' = '#f7b126'
)

# Convert the named vector to a data frame
colors_df <- data.frame(
  category = names(colors_category),  # Extract names as a column
  color = colors_category,             # Use the values as another column
  stringsAsFactors = FALSE             # Prevent automatic conversion to factors
)
create_plot_rel <- function(cols, palette,ps_meta) {
  dataex <- ps_meta %>%
    dplyr::group_by_at(cols) %>%
    dplyr::summarise(N = n()) %>%
    dplyr::mutate(rel_count = N / sum(N)) 
  
  # Perform chi-squared test
  chisq_result <- chisq.test(ps_meta[[cols[1]]], ps_meta[[cols[2]]])
  chisq_pvalue <- format(chisq_result$p.value, digits = 3)
  
  dataex[[cols[2]]] <- str_wrap(dataex[[cols[2]]], width = 10)
  cols[2] <- str_wrap(cols[2],width = 10)
  #print(dataex)
  dataex$category <- factor(cols_meta[cols[2],'category'])
 ggplot(dataex, aes(x = !!sym(cols[[1]]), y = rel_count, fill = !!sym(cols[[2]]))) +
    geom_bar(position = "stack", stat = "identity") +
    geom_text(aes(label = scales::percent(rel_count, accuracy = 1)), position = position_stack(vjust = 0.5), size = 3)  +
    labs(title = paste("Chi-squared p-value:\n", chisq_pvalue ), fill = cols[[2]]) +
    scale_fill_manual(values = palette) +
    theme_linedraw()+
    theme(axis.text.x = element_text(hjust = 1),
          legend.text =  element_text(size = 8, family = "Fira Sans"),
          legend.key.size = unit(0.5, "cm"),
          legend.title = element_text(size = 8,family = "Fira Sans",face = "bold"),
          plot.margin = margin(t = 0,  # Top margin
                             r = 1,  # Right margin
                             b = 0,  # Bottom margin
                             l = 0,  # Left margin
                             unit = "cm"))+
   facet_grid(category ~ ., scales = "free", space = "free")
}


features = rownames(sorted_cols_meta)


plot_list <- purrr::map(features, ~ {
  tryCatch({
    create_plot_rel(cols = c('phenotype',.x), palette = colors,ps_meta=ps_meta)
  }, error = function(e) {
    message(paste("Error in method:", .x))
    message(e$message)  # Print the error message
    return(NULL)  # Return NULL for this iteration
  })
})

for (i in seq_along(plot_list)) {
  plot_list[[i]] <- plot_list[[i]] + theme(strip.background.y = element_rect(fill = unique(colors_df[as.character(unique(plot_list[[i]]$data$category)),'color'])),
                                           strip.text = element_text(size = 10,color='black'))
}

# Check results
#print(plot_list)
plot_list[[1]]

combined_plot <- ggarrange(plotlist = plot_list, ncol = 4, nrow = 3)
combined_plot
ggsave("./figures/phenotype_features.png",combined_plot,dpi=300,height = 10,width=20)

```



#diff_analysis
```{r}
?octobiom::prepare_phyloseq
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'NONE',detection = 10, prevalence = 0.05,agglomeration_flag = F,first = 'filter')

meta <- as(ps_obj@sam_data,'data.frame')
meta <- meta %>%
  dplyr::mutate(phenotype = dplyr::recode(phenotype,
                             `1st` = "MHN",
                             `2nd` = "MUN",
                             `3rd` = "MHO",
                             `4th` = "MUO"))
ps_obj@sam_data <- sample_data(meta)
ps_obj@sam_data$phenotype <- factor(ps_obj@sam_data$phenotype,levels = c("MHN","MUN","MHO","MUO"))

diagdds <- phyloseq::phyloseq_to_deseq2(ps_obj ,~ phenotype)
diagdds <- DESeq(diagdds, test="Wald", fitType="parametric", sfType = "poscounts")
contrasts <- list(c("phenotype", 'MUN', 'MHN'), c("phenotype", 'MHO', 'MHN'), c("phenotype", 'MUO', 'MHN'),c("phenotype", 'MHO','MUN'),c("phenotype", 'MUO', 'MUN'),c("phenotype", 'MUO', 'MHO'))
resultsNames(diagdds)
?octobiom::create_sigtab
sigtabs_list <- list()
sigtabs_list <- lapply(contrasts, function(contrast) {
  tryCatch(
    octobiom::create_sigtab(ps_obj, diagdds, contrast),
    error = function(e) {
      message(paste("Error processing contrast:", paste(contrast, collapse = " vs "), " - ", e$message))
      return(NULL)
    }
  )
})

combined_df <- do.call(rbind, sigtabs_list)
?octobiom::create_comparison_plots
combined_df

library(Maaslin2)
?octobiom::process_maaslin

# Define methods
methods <- list(
  list(analysis_method = "CPLM", normalization = "TSS", transform = "NONE"),
  list(analysis_method = "LM", normalization = "TSS", transform = "LOG"),
  list(analysis_method = "LM", normalization = "CLR", transform = "NONE"),
  list(analysis_method = "CPLM", normalization = "CSS", transform = "NONE"),
  list(analysis_method = "CPLM", normalization = "TMM", transform = "NONE")
)
?process_maaslin
results <- process_maaslin(
  ps_obj = ps_obj,
  contrasts = contrasts,
  methods = methods,
  output_dir = '/home/kuzmichenko_pa/maaslin_test_16S/',
  ncores = 30
)

results
comparison <- 'Lean vs Obesity'
ref_group <- "Obesity"
comp_group <- "Lean"


combined_df<- combined_df %>%
  dplyr::rename(comparison_group = 'group1',reference_group = 'group2')
combined_df <- combined_df %>%
  select(Taxon,coef,model,comparison,signif,padj,Species,comparison_group,reference_group)
results_df <- results %>%
  select(Taxon,coef,model,comparison,signif,padj,Species,comparison_group,reference_group)
bmi_colors <- c(
  'Lean' = "#FF8400",
  'Overweight' = "#3C096C",
  'Obesity' = "#FF0A54"
)
?create_comparison_heatmap

heatmap_results<- octobiom::create_comparison_heatmap(data_deseq = combined_df,
                                    data_maaslin = results_df,
                                    ref_group = ref_group,
                                    comp_group = comp_group,
                                    taxa_level = 'Species',
                                    ps_obj,
                                    group_var_abund_prev = "bmi_group",
                                    group_colors_abund_prev = bmi_colors,
                                    comparison_name = comparison,
                                    heatmap_height =14,
                                    heatmap_width = 5
                                    )
heatmap_results$heatmap_plot


```
#correlation between features and taxa
```{r,fig.height=6,fig.width=6}
?octobiom::prepare_phyloseq
meta <- as(phyloseq::sample_data(ps),'data.frame')

ps@sam_data <- sample_data(meta)

ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'compositional',detection = 10, prevalence = 0.05,taxonomic_level ='Genus' ,first = 'filter')
octobiom::get_palette('set_10_4')

feature_colors <- c(
  'hs.CRP_mg.L' = "#A8BF8A",
  'HbA1C_.'="#F49AA2",
  'HDL_cholesterol_mmol.L' ="#FCCD86",
  'triglycerides_mmol.L' ="#89B7C2"
)

ps_obj@sam_data$`hs.CRP_mg.L` <- as.numeric(ps_obj@sam_data$`hs.CRP_mg.L`)
ps_obj@sam_data$`HbA1C_.` <- as.numeric(ps_obj@sam_data$`HbA1C_.`)
ps_obj@sam_data$`HDL_cholesterol_mmol.L` <- as.numeric(ps_obj@sam_data$`HDL_cholesterol_mmol.L`)
ps_obj@sam_data$`triglycerides_mmol.L` <- as.numeric(ps_obj@sam_data$`triglycerides_mmol.L`)
?build_multi_correlation_network

network_correlation_results <- octobiom::build_multi_correlation_network(
  ps_obj,
  features = c( 'hs.CRP_mg.L','HbA1C_.','HDL_cholesterol_mmol.L','triglycerides_mmol.L'),
  tax_rank = "Genus",
  cor_method = 'spearman',
  feature_colors = feature_colors,
  min_corr_strenght = 0.1,
  p_cutoff = 0.05
)
network_correlation_results


```
#correlation feature and taxa liner
```{r,fig.height=10,fig.width=10}
library(phyloseq)
library(tidyverse)
library(ggpubr)

# Ваш phyloseq объект
# ps <- readRDS("your_phyloseq_object.rds")
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'clr',detection = 10, prevalence = 0.05,taxonomic_level ='Genus' ,first = 'filter')
taxa_names(ps_obj) <- ps_obj@tax_table[,'Genus']
# Выбранные таксоны
target_taxa <- c("Christensenellaceae R-7 group", "UCG-005","Limosilactobacillus",
                 "Negativibacillus","[Eubacterium] xylanophilum group")

# Выбранные метаданные
target_metadata <- c('hs.CRP_mg.L', 'HbA1C_.', 'HDL_cholesterol_mmol.L', 'triglycerides_mmol.L')

# Извлекаем данные
otu_data <- as.data.frame((otu_table(ps_obj)))
meta_data <- as(sample_data(ps_obj),'data.frame')

# Фильтруем только нужные таксоны (убедитесь, что названия совпадают)
taxa_data <- otu_data %>% 
  select(any_of(target_taxa))

# Объединяем с метаданными
combined_data <- bind_cols(taxa_data, meta_data %>% select(any_of(target_metadata)))
combined_data <- as.data.frame(lapply(combined_data, function(x) as.numeric(as.character(x))))
colnames(combined_data)

new_names <- c(
  "Christensenellaceae R7 group" = "Christensenellaceae.R.7.group",
  "UCG-005" = "UCG.005",
  "Limosilactobacillus" = "Limosilactobacillus",
  "Negativibacillus" = "Negativibacillus",
  "[Eubacterium] xylanophilum group" = "X.Eubacterium..xylanophilum.group",
  "CRP,mg/L" = "hs.CRP_mg.L",
  "HbA1c,%" = "HbA1C_.",
  "HDL-C,mmol/L" = "HDL_cholesterol_mmol.L",
  "TG,mmol/L" = "triglycerides_mmol.L" 
)

# Переименовываем колонки
combined_data <- combined_data %>%
  rename(new_names)


target_taxa <- colnames(combined_data[1:5])
target_metadata <- colnames(combined_data[6:9])
# Функция для построения корреляций с проверкой ошибок
calculate_correlations <- function(data, taxa_cols, meta_cols) {
  results <- data.frame()
  all_p_values <- c()
  
  for (taxa in taxa_cols) {
    for (meta_var in meta_cols) {
      if (taxa %in% colnames(data) && meta_var %in% colnames(data)) {
        
        clean_data <- data %>% 
          select(all_of(c(taxa, meta_var))) %>% 
          filter(complete.cases(.))
        
        if (nrow(clean_data) >= 3) {
          tryCatch({
            cor_test <- cor.test(clean_data[[taxa]], clean_data[[meta_var]], 
                                method = "pearson")
            
            # Создаем временный data.frame
            temp_result <- data.frame(
              taxa = taxa,
              metadata = meta_var,
              correlation = as.numeric(cor_test$estimate),
              p_value = cor_test$p.value,
              n_observations = nrow(clean_data)
            )
            
            results <- rbind(results, temp_result)
            all_p_values <- c(all_p_values, cor_test$p.value)
            
          }, error = function(e) {
            message(paste("Error for", taxa, "and", meta_var, ":", e$message))
          })
        }
      }
    }
  }
  
  # Применяем поправку Бенджамини-Хохберга
  if (nrow(results) > 0) {
    results$p_value_adj <- p.adjust(results$p_value, method = "BH")
    results$significance <- ifelse(results$p_value_adj < 0.001, "***",
                                  ifelse(results$p_value_adj < 0.01, "**",
                                        ifelse(results$p_value_adj < 0.05, "*", "ns")))
  }
  
  return(results)
}


plot_correlations <- function(data, taxa_cols, meta_cols, correlation_results) {
  plots <- list()
  
  for (taxa in taxa_cols) {
    for (meta_var in meta_cols) {
      if (taxa %in% colnames(data) && meta_var %in% colnames(data)) {
        
        clean_data <- data %>% 
          select(all_of(c(taxa, meta_var))) %>% 
          filter(complete.cases(.))
        
        if (nrow(clean_data) >= 3) {
          # Находим соответствующий результат корреляции
          cor_result <- correlation_results %>%
            filter(taxa == !!taxa & metadata == !!meta_var)
          
          # Создаем текст для аннотации
          if (nrow(cor_result) > 0) {
            cor_text <- paste0("r = ", round(cor_result$correlation, 3),
                              " p_adj = ", round(cor_result$p_value_adj,3),
                              " ", cor_result$significance)
          } else {
            cor_text <- "No correlation data"
          }
          
          p <- ggplot(clean_data, aes(x = .data[[taxa]], y = .data[[meta_var]])) +
            geom_point(alpha = 0.7, color = "#E83D8F", size = 0.5) +
            geom_smooth(method = "lm", se = TRUE, 
                        color = "black", fill = "#FFB6C1", alpha = 0.3) +
            # Добавляем аннотацию с текстом корреляции
            annotate("text", 
                     x = Inf, y = Inf,
                     label = cor_text,
                     size = 5,
                     color = "black",
                     hjust = 1.1, vjust = 1.1,
                     fontface = "bold") +
            labs(x = taxa, y = meta_var) +
            theme_minimal(base_size = 12) +
            theme(
              plot.background = element_rect(fill = "white", color = NA),
              panel.background = element_rect(fill = "white", color = NA),
              panel.grid.major = element_line(color = "grey90", size = 0.2),
              panel.grid.minor = element_blank(),
              axis.line = element_line(color = "black", size = 0.3),
              axis.title = element_text(face = "bold", color = "black", size = 12),
              axis.text = element_text(color = "black", size = 8),
              plot.margin = margin(5, 5, 5, 5)
            )
          
          plots[[paste(taxa, meta_var, sep = "_")]] <- p
        }
      }
    }
  }
  return(plots)
}

correlation_results <- calculate_correlations(combined_data, target_taxa, target_metadata)

correlation_plots <- plot_correlations(combined_data, target_taxa, target_metadata, correlation_results)

# Отображаем графики
if (length(correlation_plots) > 0) {
  library(patchwork)
  
  n_cols <- 4
  n_rows <- ceiling(length(correlation_plots) / n_cols)
  
  combined_plot <- wrap_plots(correlation_plots, 
                             ncol = n_cols, 
                             nrow = n_rows)
  
  print(combined_plot)
  
  ggsave('./figures/correlation_plots.png', combined_plot, 
         dpi = 300, 
         width = n_cols * 1.7,
         height = n_rows * 1.5,
         bg = "white")
}
```
#Dif analysis
```{r,fig.height=8}
#Let's apply differential abundance analysis using the DESEq2 tool
#Prepare dataset. We need count data.
saveRDS(ps,'~/DAVID_WGS/16s_diff_analysis/Genus/data/arkh/arkh.rds')
ps@sam_data$phenotype <- as.factor(ps@sam_data$phenotype)
ps@sam_data$phenotype

library(ComplexHeatmap)
library(colorRamp2)
lgd_signif = Legend(title = "significance", col_fun = colorRamp2(c(0, 0.05,0.1), c("#8c1c13", "#bf4342","#e7d7c1")), at = c(0, 0.05, 0.1), 
    labels = c('0', '0.05','0.1'))
deseq2__maaslin2_cplm_negbin_tmm_lm_clr_Lean_vs_Obesity_SGB_heatmap <- readRDS("~/DAVID_WGS/16s_diff_analysis/ASV/heatmaps/deseq2__maaslin2_cplm_negbin_tmm_lm_clr_1st_vs_2nd_heatmap.rds")
deseq2__maaslin2_cplm_negbin_tmm_lm_clr_Lean_vs_Obesity_SGB_heatmap
png('~/DAVID_WGS/16s_diff_analysis/ASV/DA_metaphlan_1st_vs_2nd.png', height = 3500, width = 3700,res=300)
 draw(deseq2__maaslin2_cplm_negbin_tmm_lm_clr_Lean_vs_Obesity_SGB_heatmap, heatmap_legend_side = "top", annotation_legend_side = "top", merge_legend = TRUE,annotation_legend_list =c(lgd_signif),
       ht_gap = unit(c(15, 15), "mm"))
dev.off()


```
#Hir clustering
```{r,fig.height=10}
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'compositional',detection = 10,prev = 0.01,taxonomic_level = 'Genus',
                                     first = 'filter')
?octobiom::barplot_hierarchical
meta <- as(ps_obj@sam_data,'data.frame')
meta <- meta %>%
  dplyr::mutate(phenotype = recode(phenotype,
                             `1st` = "MHN",
                             `2nd` = "MUN",
                             `3rd` = "MHO",
                             `4th` = "MUO"))
ps_obj@sam_data <- sample_data(meta)
#Creates a stacked barplot of taxonomic compositions with hierarchical clustering dendrogram and sample metadata annotations for top taxa.
unique(ps_obj@sam_data$age_at_heath_check_10yr)
phenotype_colors <- c(
  'MHN' = '#a7c957',
  'MUN' = '#b80c09',
  "MHO" = '#0b4f6c',
  "MUO" = "#D5B3FF"
)
age_colors <- c(
  '35-44'='#48cae4',#blue
  '45-54' = '#a24f7c' ,
  '55-64'='#ff6b35',#orange
  '65+' = '#ef233c' #red
)
sex_colors <- c(
    'female'='#ff5c8a',
    'male' = '#0466c8'
  )
batch_colors <- c(
  'B1' = '#a7c957',
  'B3' = '#b80c09',
  "B4" = '#0b4f6c',
  "B6" = "#D5B3FF"
)
features <- c('phenotype','batch','sex',"age_at_heath_check_10yr" )
color_palette <- octobiom::get_palette("set_20_2")
color_palette <- c('white',color_palette)
colors_annotation <- list('batch' = batch_colors,'phenotype' = phenotype_colors,
                                                                     'age_at_heath_check_10yr' = age_colors,'sex' = sex_colors)
barplot_results <- octobiom::barplot_hierarchical(ps_obj,taxrank="Genus", top = 20, feature = features,
                                      dist = 'bray',colors_barplot = color_palette,
                                   colors_annotation = colors_annotation,decreasing = T,
                                   size = c(0.5,0.2,0.2,0.2,0.2,5))
barplot_results
#ggsave('./figures/barplot_hierarchical.png',barplot_results,dpi = 300,width = 16,height = 10)
```
#Correlation
```{r,fig.height=8}
library(octobiom)

ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'NONE',detection = 10,prev = 0.1,taxonomic_level = 'taxa_names',
                                     first = 'filter')
taxa_names(ps_obj) <- ps_obj@tax_table[,'taxa_names']
otu_tab <- as.data.frame(t(ps_obj@otu_table))
otu_tab

# Настройки
output_root <- "~/DAVID_WGS/fastspar_output"
n_bootstraps <- 2  # Тестово 2 итерации (можно увеличить до 30+)
base_otu_name <- "otu_table_filtered"
conda_env <- "fastspar"
threads <- 10
cor_threshold <- 0.3

if (!dir.exists(output_root)) {
  dir.create(output_root, recursive = TRUE)
}


all_network_results <- list()

for (i in 1:n_bootstraps) {

  otu_boot <- octobiom::bootstrap_otu_table(otu_tab,sample_size=300,with_replacement = F,random_seed = i)

  boot_id <- sprintf("boot%02d", i)  # boot01, boot02, ...
  output_dir <- file.path(output_root, paste0("results_", boot_id))
  otu_filename <- paste0(base_otu_name, "_", boot_id, ".txt")
  

  dir.create(output_dir, showWarnings = FALSE)
  df_to_write <- data.frame("#OTU ID" = rownames(otu_boot), otu_boot, check.names = FALSE)
  write.table(
    df_to_write,
    file = file.path(output_root, otu_filename),
    sep = "\t",
    row.names = FALSE,     
    quote = FALSE,
    col.names = TRUE
  ) 
}
  
for (i in 1:n_bootstraps) {
  boot_id <- sprintf("boot%02d", i)
  output_dir <- file.path(output_root, paste0("results_", boot_id))
  otu_filename <- paste0(base_otu_name, "_", boot_id, ".txt")
  network_res <- octobiom::run_fastspar_analysis(
    conda_env = conda_env,
    input_dir = output_root,
    output_dir = output_dir,
    otu_table = otu_filename,
    threads = threads,
    ps_obj = ps_obj,
    cor_threshold = cor_threshold
  )
  

  all_network_results[[boot_id]] <- list(
    otu_table = otu_boot,
    graph = network_res$graph,
    network = network_res$plot,
    network_stats = network_res$network_stats,
    boot_id = boot_id
  )
  

  #saveRDS(network_res, file.path(output_dir, paste0("network_results_", boot_id, ".rds")))
}
all_network_results$boot01
all_network_results$boot02
# Сохранение всех результатов в один файл
saveRDS(all_network_results, file.path(output_root, "combined_network_results.rds"))

# Вывод структуры результатов
str(all_network_results, max.level = 2)
#rank_names(ps)


?octobiom::bootstrap_otu_table
otu_bootstrap <- octobiom::bootstrap_otu_table(otu_table = otu_tab,sample_size=300,with_replacement = F,random_seed = 42)
otu_bootstrap
write.table(t(ps_obj@otu_table),'~/DAVID_WGS/fastspar_output/otu_table_filtered.txt',sep = "\t",
            row.names = TRUE)
?octobiom::run_fastspar_analysis

networks_results <- run_fastspar_analysis(conda_env = "fastspar",
                                          input_dir = '~/DAVID_WGS/fastspar_output',
                                          output_dir = '~/DAVID_WGS/fastspar_output/results',
                                          otu_table = 'otu_table_filtered.txt',
                                          threads = 10,ps_obj = ps_obj,cor_threshold = 0.5)
networks_results$plot

```
#Differential analysis DESEQ2
```{r,fig.height=5}
library(DESeq2)
library(phyloseq)
#Let's apply differential abundance analysis using the DESEq2 tool
#Prepare dataset. We need count data.
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'NONE',detection = 10, prevalence = 0.05,taxonomic_level = 'taxa_names',first = 'filter')

diagdds <- phyloseq::phyloseq_to_deseq2(ps_obj ,~ phenotype + sex + batch + age_at_heath_check_10yr + smoking_status + drinking_level)
diagdds <- DESeq(diagdds, test="Wald", fitType="parametric", sfType = "poscounts")


contrasts <- list(
  c("phenotype", '1st', '2nd'),
  c("phenotype", '1st', '3rd'),
  c("phenotype", '1st', '4th'),
  c("phenotype", '2nd','3rd'),
  c("phenotype", '2nd', '4th'),
  c("phenotype", '3rd', '4th'))
contrast
resultsNames(diagdds)
?octobiom::create_sigtab
sigtabs_list <- list()
sigtabs_list <- lapply(contrasts, function(contrast) {
  tryCatch(
    octobiom::create_sigtab(ps_obj, diagdds, contrast),
    error = function(e) {
      message(paste("Error processing contrast:", paste(contrast, collapse = " vs "), " - ", e$message))
      return(NULL)
    }
  )
})

identical(sort(taxa_names(ps_obj)), sort(rownames(diagdds)))
combined_df <- do.call(rbind, sigtabs_list)
?octobiom::create_comparison_plots
combined_df
?octobiom::calculate_abundance_stats



comparison_names <- unique(combined_df$comparison)

phenotype_colors <- c(
  '1st' = '#a7c957',
  '2nd' = '#b80c09',
  "3rd" = '#0b4f6c',
  "4th" = "#D5B3FF"
)
phylum_colors <- c(
  'Euryarchaeota'              = "#001219" ,
  'Thaumarchaeota'             = "#005f73" ,
  'Actinobacteria'             = "#0a9396" ,
  'Bacteria_unclassified'      = "#94d2bd" ,
  'Bacteroidetes'              = "#e9d8a6" ,
  'Candidatus_Melainabacteria' = "#ee9b00" ,
  'Candidatus_Saccharibacteria'= "#ca6702" ,
  'Firmicutes'                 = "#bb3e03" ,
  'Fusobacteria'               = "#ae2012" ,
  'Lentisphaerae'              = "#9b2226" ,
  'Proteobacteria'             = '#F55B66' ,
  'Synergistetes'              = '#ACACAC' ,
  'Tenericutes'                = '#5CD5DA' ,
  'Verrucomicrobia'            = '#0089DF' ,
  'Ascomycota'                 = '#19427D'
)
plot_diff_list <- purrr::map(comparison_names, ~ {
  tryCatch({
    octobiom::create_comparison_barplot(data = combined_df, comparison_name = .x, group_var_abund_prev = "phenotype",
                                                group_var_fold_change = "Phylum",
                                                ps_obj = ps_obj,
                                                group_colors_abund_prev =  phenotype_colors,
                                                group_colors_fold_change = phylum_colors)
  }, error = function(e) {
    message(paste("Error in method:", .x))
    message(e$message)  # Print the error message
    return(NULL)  # Return NULL for this iteration
  })
})
plot_diff_list

```
```{r,fig.height=6}
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'NONE',detection = 10, prevalence = 0.05,taxonomic_level = 'taxa_names',first = 'filter')

?octobiom::process_maaslin
# Define methods

?process_maaslin
methods <- list(
  list(analysis_method = "CPLM", normalization = "TSS", transform = "NONE"),
  list(analysis_method = "LM", normalization = "TSS", transform = "LOG"),
  list(analysis_method = "LM", normalization = "CLR", transform = "NONE"),
  list(analysis_method = "CPLM", normalization = "CSS", transform = "NONE"),
  list(analysis_method = "CPLM", normalization = "TMM", transform = "NONE")
)

#results <- process_maaslin(
#  ps_obj = ps_obj,
#  comparison_group = "phenotype",
#  methods = methods,
#  fixed_effects = c("phenotype",'sex','batch','age_at_heath_check_10yr','smoking_status','drinking_level'),
#  reference = c("phenotype, 1st","batch,B1","smoking_status,No, ex-smoker","drinking_level,Non-problem drinkers"),
#  ncores = 1,
#  output_dir = '/home/kuzmichenko_pa/maaslin_results_asv/'
#)
results <- read.csv('/home/kuzmichenko_pa/maaslin_results_asv/results.csv')

tax_table <- as(phyloseq::tax_table(ps_obj),'data.frame')
tax_table <- tax_table %>%
  tibble::rownames_to_column('Taxon')

unique_comparison <- unique(results$comparison)
heatmap_results <- list()

combined_df
?create_comparison_heatmap

for (current_comparison in unique_comparison) {
  #current_comparison <- unique_comparison[[6]]
  results_filtered <- results %>%
    dplyr::filter(comparison == current_comparison) %>%
    dplyr::filter(value == strsplit(current_comparison,split='_')[[1]][2])
  results_filtered$comparison_group <- strsplit(current_comparison,split='_')[[1]][1]
  results_filtered <- results_filtered %>%
    dplyr::rename(reference_group = 'value',padj = 'qval',Taxon = 'feature') %>%
    dplyr::left_join(tax_table , by = 'Taxon') %>%
    #tibble::rownames_to_column("temp_rowname") %>%
    #dplyr::mutate(taxa_name = paste0(temp_rowname,'|',Genus)) %>%
    dplyr::select(Taxon,coef,padj,model,reference_group,comparison_group,comparison,taxa_names)#taxa_names)
  results_filtered$signif <- ifelse(
    results_filtered$padj <= 0.001, "***",
    ifelse(
      results_filtered$padj <= 0.01, "**",
      ifelse(results_filtered$padj <= 0.05, "*", "")
    )
  )
  results_filtered <- results_filtered %>%
    dplyr::filter(padj < 0.05)
  #combined_df_filtered$taxa_name <- paste0(rownames(combined_df),'|',combined_df$Genus)
  combined_df_filtered <- combined_df %>%
    dplyr::filter(comparison == current_comparison) %>%
    #tibble::rownames_to_column("temp_rowname") %>%
    #dplyr::mutate(taxa_name = paste0(temp_rowname,'|',Genus)) %>%
    dplyr::rename(reference_group = 'group1',comparison_group = 'group2') %>%
    dplyr::select(Taxon,coef,model,comparison,signif,padj,comparison_group,reference_group,taxa_names)#taxa_names)
  
  heatmap_results[[current_comparison]]<- octobiom::create_comparison_heatmap(data_deseq = combined_df_filtered,
                                    data_maaslin = results_filtered,
                                    ref_group = strsplit(current_comparison,split='_')[[1]][1],
                                    comp_group = strsplit(current_comparison,split='_')[[1]][2],
                                    taxa_level = 'taxa_names',
                                    ps_obj,
                                    group_var_abund_prev = "phenotype",
                                    group_colors_abund_prev = phenotype_colors,
                                    comparison_name = current_comparison,
                                    heatmap_height =10,
                                    heatmap_width = 8,
                                    number_model_true = 3,
                                    output_pathway = '/home/kuzmichenko_pa/maaslin_results_asv/',
                                    width_figure = 3000,
                                    height_figure = 2600
                                    )
  
}


heatmap_results
results_filtered
combined_df_filtered
strsplit(current_comparison,split='_')[[1]][1]
ggsave('/home/kuzmichenko_pa/maaslin_results_genus/1_4.png',heatmap_results[[3]]$heatmap_plot,width = 10, height=6,dpi=300)

annotation_legend <- Legend(
    title = "phenotype",
    at = names(phenotype_colors),
    legend_gp = gpar(fill = phenotype_colors),
    direction = "vertical",
    labels_gp = gpar(fontsize = text_size)
  )

png("/home/kuzmichenko_pa/maaslin_results_genus/1_4.png", width = 3000, height = 2600, res = 300, bg = "white")
ComplexHeatmap::draw(
  heatmap_results[[3]]$heatmap_obj,
  heatmap_legend_side = "top",
  annotation_legend_side = "right",
  annotation_legend_list = list(annotation_legend)
)
dev.off()
```
#Beta
```{r,fig.height=8,fig.width=8}
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'compositional',detection = 10,prev = 0.05,taxonomic_level = 'taxa_names',
                                     first = 'filter')
?octobiom::create_ordination_plots
meta <- as(ps_obj@sam_data,'data.frame')
meta <- meta %>%
  dplyr::mutate(phenotype = dplyr::recode(phenotype,
                             `1st` = "MHN",
                             `2nd` = "MUN",
                             `3rd` = "MHO",
                             `4th` = "MUO"))
ps_obj@sam_data <- sample_data(meta)
ps_obj@sam_data$phenotype <- factor(ps_obj@sam_data$phenotype,levels = c('MHN','MUN','MHO','MUO'))
ps_obj@sam_data$batch <- factor(ps_obj@sam_data$batch,levels = c('B1','B3','B4','B6'))

#Let's analyze beta diversity
features <- c('phenotype','batch')
?octobiom::create_ordination_plots
group <- c('phenotype','batch')

color_palette <- c(octobiom::get_palette("set_2_1"),octobiom::get_palette("set_2_3"))
additional_palette <- octobiom::get_palette("set_10_4")
plot_beta_list <- purrr::map(features, ~ {
  tryCatch({
    octobiom::create_ordination_plots(ps_obj, group= .x, 
                                      distance_method = "bray",palette = color_palette,taxa_plot = FALSE)
  }, error = function(e) {
    message(paste("Error in method:", .x))
    message(e$message)  # Print the error message
    return(NULL)  # Return NULL for this iteration
  })
})
plot(plot_beta_list[[1]])
plot(plot_beta_list[[2]])

ggsave('./figures/beta_phenotypes_genus.png',plot_beta_list[[1]],dpi=300,width=10,height=10)
ggsave('./figures/beta_batch_genus.png',plot_beta_list[[2]],dpi=300,width=10,height=10)

?octobiom::create_ordination_plots_double
beta_double <- create_ordination_plots_double(ps_obj,
                                              group = 'phenotype',
                                              additional_group = 'batch',
                                              palette = color_palette,
                                              additional_palette = additional_palette ,
                                              shape_palette = c(1,2,3,4),ratio = c(3, 5)
                                              )
ggsave('./figures/beta_phenotypes_batch_asv.png',beta_double,dpi=300,width=11,height=10)
plot(beta_double)
```
#Alpha
```{r,fig.height=7,fig.width=8}
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'compositional',detection = 10,prev = 0.05,taxonomic_level = 'taxa_names',
                                     first = 'filter')
meta <- as(ps_obj@sam_data,'data.frame')
meta <- meta %>%
  dplyr::mutate(phenotype = recode(phenotype,
                             `1st` = "MHN",
                             `2nd` = "MUN",
                             `3rd` = "MHO",
                             `4th` = "MUO"))
ps_obj@sam_data <- sample_data(meta)
?octobiom::create_alpha_plots
#Let's analyze alpha diversity
features <- c('phenotype')#,'sex',
              #"smoking_status","YEAR" )
color_palette <- octobiom::get_palette("set_10_4")
plot_alpha_list <- purrr::map(features, ~ {
  tryCatch({
    octobiom::create_alpha_plots(ps_obj, col= .x, colors = color_palette,measure = c("Shannon",'Simpson'),size=18,text_size=5,bracket_nudge_y = 0.1)
  }, error = function(e) {
    message(paste("Error in method:", .x))
    message(e$message)  # Print the error message
    return(NULL)  # Return NULL for this iteration
  })
})
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'NONE',detection = 10,prev = 0.05,taxonomic_level = 'taxa_names',
                                     first = 'filter')
meta <- as(ps_obj@sam_data,'data.frame')
meta <- meta %>%
  dplyr::mutate(phenotype = recode(phenotype,
                             `1st` = "MHN",
                             `2nd` = "MUN",
                             `3rd` = "MHO",
                             `4th` = "MUO"))
ps_obj@sam_data <- sample_data(meta)
plot_alpha_list_chao <- purrr::map(features, ~ {
  tryCatch({
    octobiom::create_alpha_plots(ps_obj, col= .x, colors = color_palette,measure = c("Chao1"),size=18,text_size=5,bracket_nudge_y = 0.1)
  }, error = function(e) {
    message(paste("Error in method:", .x))
    message(e$message)  # Print the error message
    return(NULL)  # Return NULL for this iteration
  })
})
plot_alpha_list_chao

p <- ggpubr::ggarrange(plot_alpha_list[[1]]$plots,plot_alpha_list_chao[[1]]$plots,widths = c(2,1))
p <- (plot_alpha_list[[1]]$plots | plot_alpha_list_chao[[1]]$plots) + 
  plot_layout(widths = c(2, 1)) &
  theme(plot.margin = unit(c(0.5, 0.5, 0, 0), "cm"))
p
ggsave('./figures/alpha_phenotype_asv.png',p,dpi=300,width=8,height=6)
```
#Сети 
```{r,fig.height=8,fig.width=8}
ps_obj <- octobiom::prepare_phyloseq(ps,transformation = 'NONE',detection = 10, prevalence = 0.15,taxonomic_level = 'taxa_names',first = 'filter')
otu_tab <- t(ps_obj@otu_table)
df_to_write <- data.frame("#OTU ID" = rownames(otu_tab), otu_tab, check.names = FALSE)
write.table(
    df_to_write,
    file ='~/DAVID_WGS/fastspar_output/otu_table_filtered.txt',
    sep = "\t",
    row.names = FALSE,     
    quote = FALSE,
    col.names = TRUE
  ) 
#write.table(t(ps_obj@otu_table),'~/DAVID_WGS/fastspar_output/otu_table_filtered.txt',sep = "\t",
#            row.names = TRUE)
?octobiom::run_fastspar_analysis

networks_results <- run_fastspar_analysis(conda_env = "fastspar",
                                          input_dir = '~/DAVID_WGS/fastspar_output',
                                          output_dir = '~/DAVID_WGS/fastspar_output/results',
                                          otu_table = 'otu_table_filtered.txt',
                                          threads = 10,ps_obj = ps_obj,cor_threshold = 0.5)

```
#metadata
```{r}
df <- read.csv('./DATA/meta.csv',sep=',')
library(dplyr)
colnames(ps@sam_data)
# Предположим, что ваш датафрейм называется dfзы"
summary_table <- df %>%
  group_by(phenotype) %>%
  summarise(
    age_mean = mean(age_at_heath_check, na.rm = TRUE),
    dietary_quality_median = median(dietary_quality_score_cat, na.rm = TRUE),
    phys_act_mean = mean(total_phys_act_index, na.rm = TRUE),
    triglycerides_mean = mean(triglycerides_mmol.L, na.rm = TRUE),
    HDL_cholesterol_mean = mean(HDL_cholesterol_mmol.L, na.rm = TRUE),
    HbA1C_mean = mean(HbA1C_., na.rm = TRUE)
    # Можно добавить и другие показатели
  )
```
